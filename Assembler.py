"""Assembler

This module uses the Lex module to parse a program following the format defined
in README and then convert it to a simple assembly program. The assembly
language is described in the Compiler module. This assembler produces admittedly
inefficient code. The main priorities in this implementation are simplicity and
reliability.
"""

import os

import Lex
from TokenCodes import *


class SyntaxException(Exception):
    pass


class Assembler:
    """Analyzes the syntax of of a program and produces its assembly code."""

    def __init__(self, input, debug=False):
        """Takes code, creates a lexeme table, and generates assembly code."""
        self.analyser = Lex.Lex(input, debug)
        self.jumpnum = 0
        self.i = 0  # Index of lexeme list.
        self.lexemes = self.analyser.lexemes
        self.assembly = self.parse()

        # If debugging is enabled, set it up.
        if debug:
            self.out = open(os.path.join(os.getcwd(), "assembler_output.txt"), "w")
            self.out.write(self.assembly)
            self.out.close()

    def __str__(self):
        """Returns the assembly represenation of this assembler's given code."""
        return self.assembly

    def parse(self):
        """Commence parsing of the given list of lexemes."""
        return self.program()

    def program(self):
        """Parses strings in the language generated by the rule:
           <program> -> <series>
        """
        return self.series()

    def series(self):
        """Parses strings in the language generated by the rule:
           <series> -> <statement> | <statement>; <series>
        """
        code = self.statement()
        while len(self.lexemes) > self.i and self.lexemes[self.i].type == SEMICOLON:
            self.i += 1
            code += self.statement()
        return code

    def segment(self):
        """Parses strings in the language generated by the rule:
           <segment> -> <assign statement> | <assign statement>; <segment>
        """
        code = self.assign()
        while self.lexemes[self.i].type == SEMICOLON:
            self.i += 1
            code += self.assign()
        return code
                        
    def statement(self):
        """Parses strings in the language generated by the rule:
           <statement> -> <assign statement> | <definite loop>
        """
        if len(self.lexemes) > 2:
            if self.lexemes[self.i].type == VARIABLE:
                return self.assign()
            elif self.lexemes[self.i].text == "TO":
                return self.loop()
            else:
                raise SyntaxException(self.lexemes[self.i].text)
        else:
            raise SyntaxException

    def assign(self):
        """Parses strings in the language generated by the rule:
           <assign statement> -> <variable> := <expression>
        """
        if self.lexemes[self.i + 1].type == ASSIGN_OP:
            variable = self.variable()
            self.i += 1  # Skipping over assignment operator.
            expression = self.expression()
            return "%sMOV %s AC\n" % (expression, variable)
        else:
            raise SyntaxException("Expected assignment operator.")

    def loop(self):
        """Parses strings in the language generated by the rule:
        <definite loop> -> TO <expression> DO <segment> END
        """
        # The expression begins the loop code.
        self.i += 1
        code = self.expression()

        # End value gets stored in loop register.
        code += "MOV ECX AC\n"

        # Set a numbered label to jump to.
        code += "label%s:\n" % (self.jumpnum)

        # Inside the loop, decrement the counter first.
        code += "SUB ECX 1\n"

        # Add code to execute inside the loop.
        if self.lexemes[self.i].text == "DO":
            self.i += 1  # Skip over the DO.
            code += self.segment()
        else:
            raise SyntaxException(self.lexemes[self.i].text)

        # Jump if loop register if the counter is less than the loop register.
        code += "JMP label%s\n" % (self.jumpnum)

        # Skip over END.
        if self.lexemes[self.i].text == "END":
            self.i += 1
        else:
            raise SyntaxException("Expected END, but got %s." % (self.lexemes[self.i].text))

        # Increment the jump label number.
        self.jumpnum += 1

        return code
        
    def expression(self):
        """Parses strings in the language generated by the rule:
           <expression> -> <element> | <element> <math operator> <element>
        """
        # Define a convenient dict to map math to assembly operators.
        operators = {"+": "ADD",
                     "-": "SUB",
                     "*": "MUL",
                     "/": "DIV"}

        if len(self.lexemes[self.i:]) > 2 and self.lexemes[self.i + 1].type == MATH_OP:
            element1 = self.element()
            operator = operators[self.lexemes[self.i].text]
            self.i += 1
            element2 = self.element()
            return "MOV AC %s\n%s AC %s\n" % (element1, operator, element2)
        else:
            return "MOV AC %s\n" % (self.element())
            

    def element(self):
        """Parses strings in the language generated by the rule:
           <element> -> <constant> | <variable>
        """
        if self.lexemes[self.i].type == VARIABLE:
            return self.variable()
        elif self.lexemes[self.i].type == CONSTANT:
            return self.constant()
        else:
            raise SyntaxException

    def variable(self):
        """Returns the value of the variable next in the lexemes list."""
        text = self.lexemes[self.i].text
        self.i += 1
        return text
    
    def constant(self):
        """Returns the value of the constant next in the lexemes list."""
        text = self.lexemes[self.i].text
        self.i += 1
        return text


def get_next_index(lexemes, text):
    """Returns the index of the next lexeme in the given list whose text matches
       the given text.
    """
    for lex in lexemes:
        if lex.text == text:
            return lexemes.index(lex)
    return None
